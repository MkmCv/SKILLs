---
name: build-flash-debug
description: 全自动编译、烧录、串口调试 ARCS SDK 示例程序，支持自动修复编译错误并验证板上运行结果
---

# ARCS SDK 全自动编译烧录调试器

在 Linux 环境下对 ARCS SDK 示例程序执行完整的 编译 → 烧录 → 串口验证 工作流。自动识别硬件连接、阅读示例文档、编译固件、烧录到板子、通过串口监控运行结果并判断是否正常工作。

**每次执行结束后，会将遇到的问题和解决方案记录到经验报告中，并据此自优化本 skill。**

## 快速使用

```
编译烧录 samples/drivers/devices/lisa_wdt/basic
编译运行 lisa_gpio output_basic
帮我把 helloworld 烧到板子上看看
调试 lisa_uart send_async_dma
批量编译烧录 lisa_wdt 下所有示例
批量验证 lisa_gpio lisa_uart lisa_pwm
```

### 批量模式

支持一次处理多个示例，逐个执行完整的 编译→烧录→验证 流水线：

- `批量编译烧录 lisa_wdt 下所有示例`：自动遍历该目录下所有子示例
- `批量验证 lisa_gpio lisa_uart lisa_pwm`：按顺序逐个处理指定的多个示例
- 因为串口设备同一时间只能被一个操作使用，所以是**逐个串行执行**，不是并行
- 每个示例独立生成验证报告，最后输出一份汇总报告
- 某个示例失败不影响后续示例继续执行

## 默认配置

以下为默认值，用户可在触发时覆盖：

| 参数 | 默认值 | 说明 |
|------|--------|------|
| BOARD | `arcs_evb` | 目标开发板 |
| 串口设备 | `/dev/ttyACM0` | USB 串口路径 |
| 烧录波特率 | `3000000` | cskburn 波特率 |
| 串口波特率 | `921600` | picocom 监听波特率 |
| 烧录起始地址 | `0x0` | Flash 烧录偏移 |

## 核心原则：先确认非偶发，再处理

在调试阶段遇到任何异常现象时，**必须先通过重复验证确认问题是否稳定复现**，再决定是否需要修复。具体做法：

1. **首次出现异常**：记录现象，不急于下结论
2. **重复验证 2-3 次**：用相同条件重新执行，观察是否一致复现
3. **判定结论**：
   - 如果每次都复现 → 确认为真实问题，进入排查修复流程
   - 如果仅偶发 → 标记为「偶发/环境因素」，在报告中注明，不作为代码问题处理
4. **区分根因**：区分是代码 bug、硬件问题、环境因素（如 USB 信号、串口时序）还是工具链问题

## 执行步骤

### 第一阶段：环境检查

#### 1. 确认仓库路径

- 确认当前工作目录位于 `arcs-sdk` 仓库根目录
- 验证 `build.sh`、`tools/burn/cskburn` 等关键文件存在
- 如果不在仓库根目录，尝试通过 `git rev-parse --show-toplevel` 定位

#### 2. 检查硬件连接

**串口设备发现策略**（设备号可能变化，不要硬编码 ACM0）：

```bash
# 第一步：扫描所有可能的串口设备
ls /dev/ttyACM* /dev/ttyUSB* 2>/dev/null
```

- 如果找到**唯一设备**（如 `/dev/ttyACM0`），直接使用
- 如果找到**多个设备**（如 `ACM0` 和 `ACM1`），运行 `udevadm info -q all -n /dev/ttyACMx` 查看 vendor/product 信息，识别目标设备，并询问用户确认
- 如果**找不到任何设备**：
  - 运行 `lsusb` 查看 USB 设备列表
  - 运行 `dmesg | tail -20` 查看最近的 USB 事件
  - **告知用户硬件未连接，请求确认后继续**
- 确认设备权限（用户是否在 `dialout` 组中）
- 检查是否有其他进程占用串口：`fuser <串口设备> 2>/dev/null`，如有占用提示用户

**重要**：在整个流程中，如果某个步骤突然找不到设备，先执行 `ls /dev/ttyACM* /dev/ttyUSB*` 重新扫描，设备号可能已经变化（USB 重新枚举）。

#### 3. 检查工具链

- 验证 `listenai-dev-tools/` 目录存在（cmake、ninja、toolchain）
- 如果缺失，提示用户运行 `bash prepare_listenai_tools.sh`

#### 4. 读取经验知识库

- 读取 `.claude/skills/build-flash-debug/knowledge.md`（如果存在）
- 获取历史问题和解决方案，用于本次执行的预判和快速处理

### 第二阶段：理解示例

#### 5. 定位示例目录

- 根据用户输入定位示例路径，例如：
  - `lisa_wdt basic` → `samples/drivers/devices/lisa_wdt/basic/`
  - `helloworld` → `samples/helloworld/`
  - 完整路径直接使用
- 如果找不到，在 `samples/` 下搜索匹配的目录名

#### 6. 阅读示例文档

- **必须阅读** 示例目录下的 `README.md` 或 `README.rst`
- 从文档中提取关键信息：
  - **功能说明**：理解这个示例要做什么
  - **硬件连接**：是否需要外部接线（如需要，提醒用户确认）
  - **预期输出**：作为后续验证的参考标准
  - **编译方法**：检查是否使用标准编译流程还是有特殊参数
  - **注意事项**：可能影响运行结果的特殊注意点

#### 7. 阅读源代码

- 阅读示例的 `src/main.c`（或其他源文件）和 `CMakeLists.txt`
- 理解代码逻辑，用于后续判断串口输出是否正确
- 注意代码中的 `printk`/`printf` 输出内容，作为串口验证依据
- 检查 `prj.conf` 和 `Kconfig` 了解配置项

### 第三阶段：编译

#### 8. 执行编译

在仓库根目录下进入示例目录执行编译：

```bash
cd <示例目录>
bash ./build.sh -C -DBOARD=arcs_evb && bash ./build.sh -r -w -DBOARD=arcs_evb
```

**注意：**
- `build.sh` 路径需要根据示例目录的相对位置调整，通常示例的 `build.sh` 是一个软链接或直接使用仓库根目录的 `build.sh`
- 如果示例目录下有自己的 `build.sh`，优先使用它
- 如果没有，回到仓库根目录使用 `-S <示例路径>` 参数编译：
  ```bash
  bash ./build.sh -C -S <示例相对路径> -DBOARD=arcs_evb && bash ./build.sh -r -w -S <示例相对路径> -DBOARD=arcs_evb
  ```
- `-C` 表示先清理构建目录
- `-r` 表示 Release 模式
- `-w` 表示 warnings as errors

#### 9. 处理编译错误

如果编译失败：

1. **仔细阅读错误输出**，提取错误信息
2. **查阅经验知识库**（knowledge.md）看是否有已知解决方案
3. **分类处理**：
   - **头文件找不到**：检查 `CMakeLists.txt` 的 include 路径、`prj.conf` 配置
   - **未定义符号**：在仓库中搜索相关符号定义，检查是否缺少依赖
   - **类型错误**：阅读相关 API 头文件，修正代码
   - **链接错误**：检查 `CMakeLists.txt` 依赖、`Kconfig` 配置
   - **配置错误**：检查 `prj.conf` 和 `Kconfig`
4. **在仓库中搜索**相关代码、头文件、配置来定位问题：
   - 使用 Grep 搜索错误涉及的函数/类型/宏定义
   - 查看 `drivers/`、`components/`、`modules/` 下的相关实现
5. **修复后重新编译**
6. **最多尝试 3 轮自动修复**，如果仍然失败，向用户报告问题并请求协助
7. **记录问题**：无论是否自动修复成功，都记录到本次问题清单

#### 10. 确认编译产物

- 编译成功后，定位固件文件
- 通常在示例目录的 `build/` 子目录下
- 常见固件文件名模式：`*.bin`、`*.hex`、`*firmware*`
- 检查 `build/` 下查找烧录用的二进制文件（通常是 `.bin` 文件）
- 如果找不到，检查编译输出日志中提到的输出路径

### 第四阶段：烧录

#### 11. 烧录前再次确认设备

```bash
# 重新扫描，因为编译期间设备号可能变化
ls /dev/ttyACM* /dev/ttyUSB* 2>/dev/null
fuser <目标设备> 2>/dev/null
```

如果设备号变了，更新后续所有命令中的设备路径。

#### 12. 执行烧录

使用 cskburn 烧录固件：

```bash
./tools/burn/cskburn -C arcs -s <串口设备> -b 3000000 0x0 <固件文件路径>
```

**参数说明**：
- `-C arcs`：芯片类型
- `-s <串口设备>`：串口设备（使用第 2 步发现的设备）
- `-b 3000000`：烧录波特率
- `0x0`：Flash 起始地址
- 最后一个参数是固件 `.bin` 文件路径

**烧录失败处理**：
- `EBUSY`：有进程占用串口，用 `fuser` 查找并提示用户
- `ETIMEDOUT`：
  1. 等待 3 秒后重新扫描设备（设备号可能变了）
  2. 用新设备路径重试
- 设备消失：USB 可能断连重连，等待后重新扫描 `/dev/ttyACM*`

### 第五阶段：串口验证

#### 13. 打开串口监控

烧录成功后，使用 pyserial 读取串口（picocom 在非 TTY 环境下不可用）：

```python
import serial, time
ser = serial.Serial('<串口设备>', 921600, timeout=0.5)
ser.reset_input_buffer()
# DTR/RTS 复位序列
ser.dtr = False; ser.rts = False
time.sleep(0.1)
ser.dtr = True; ser.rts = True
time.sleep(0.1)
ser.dtr = False; ser.rts = False
time.sleep(0.5)
# 读取输出...
```

**串口乱码处理**：
串口输出出现乱码时，**不要直接判定为程序异常**，按以下步骤排查：

1. **首次乱码**：可能是 DTR/RTS 复位时序导致的瞬态现象，记录但不处理
2. **清空缓冲区后重试**：`ser.reset_input_buffer()` 后再读取
3. **如果持续乱码**：
   - 检查波特率是否匹配（bootloader 阶段可能使用不同波特率）
   - 尝试关闭串口、等待 2 秒、重新打开
   - 设备可能已经重新枚举，重新扫描 `/dev/ttyACM*`
4. **最终手段**：重新烧录后立刻读取

**串口设备断连处理**：
如果读取时出现 `SerialException`（device disconnected），说明 USB 设备断连重连了：
1. 关闭当前串口连接
2. 等待 2-3 秒
3. 重新扫描 `/dev/ttyACM*` 找到新设备
4. 用新设备路径重新打开串口

#### 14. 分析串口输出（遵循「先确认非偶发」原则）

将串口输出与第 6、7 步获取的信息对比：

1. **对照预期输出**：与 README 中的「预期输出」章节对比
2. **对照代码逻辑**：检查 `printk`/`printf` 的输出是否按预期顺序和内容出现
3. **检查异常**：
   - 是否有 `ASSERT`、`FATAL`、`panic`、`fault` 等错误信息
   - 是否有 HardFault 或其他异常堆栈
   - 是否有无限重启循环（反复出现启动日志）
4. **发现异常时**：
   - 用相同条件重复验证 2-3 次
   - 区分「每次都复现」vs「仅首次出现」vs「间歇性」
   - 只有稳定复现的问题才判定为代码/驱动 bug

#### 15. 输出验证报告

向用户报告验证结果：

```
## 运行验证报告

**示例**: <示例名称>
**目标板**: <BOARD>
**串口设备**: <实际使用的设备路径>
**状态**: 正常运行 / 存在异常

### 预期行为
<基于 README 和代码的预期行为描述>

### 实际输出
<关键串口输出内容>

### 判定结果
<对比分析结论>

### 备注
<如有异常的进一步分析或建议>
```

### 第六阶段：问题记录与经验积累

#### 16. 生成本次执行报告

每次执行结束后（无论成功或失败），在 `.claude/skills/build-flash-debug/reports/` 目录下生成一份报告：

**文件名格式**：`YYYY-MM-DD_<示例名称>.md`（如 `2026-02-25_lisa_wdt_basic.md`）

```markdown
# 执行报告：<示例名称>

**日期**: YYYY-MM-DD
**操作者环境**: <串口设备、BOARD 等>
**最终状态**: 成功 / 失败 / 部分成功

## 执行摘要

<1-2 句话概述>

## 遇到的问题

### [类别] 问题标题
- **现象**: 具体描述
- **是否偶发**: 是/否（验证了几次）
- **根因**: 分析结果
- **解决方案**: 具体操作
- **耗时**: 大约花了多少轮尝试

## 关键数据

- 编译时间: <大约>
- 编译产物大小: <bytes>
- 烧录用时: <大约>
- 串口验证时长: <seconds>

## 给后续使用者的建议

<基于本次经验的提示>
```

#### 17. 更新经验知识库

读取 `.claude/skills/build-flash-debug/knowledge.md`（如不存在则创建），将本次遇到的**新问题和解决方案**追加到对应 topic 下。

知识库按 4 个 topic 组织：编译 / 烧录 / 串口 / 代码调试。遇到问题时只需读取对应 topic 即可。

**更新规则**：
- **去重合并优先**：如果本次问题与已有条目属于同一类问题，只更新该条目的「次数」字段，不新增条目
- 只有**全新类型**的问题才追加新条目
- 知识库应保持精简，每个 topic 控制在 5-8 条以内，避免臃肿
- **topic 满时**：提醒用户该 topic 已满，建议审查是否有可合并或可淘汰的条目

#### 18. 自优化 SKILL.md（谨慎执行）

如果本次执行中发现了**经验知识库中尚未涵盖的通用性问题**，且该问题的解决方案应该成为 skill 流程的一部分，则：

1. **不要直接修改 SKILL.md**
2. 在执行报告末尾添加一段 `## SKILL 优化建议`，描述建议的改动
3. 告知用户有优化建议，由用户决定是否采纳
4. 用户确认后再更新 SKILL.md

这样确保 skill 的改动是经过人工审核的，避免自动改坏。

## 特殊情况处理

### 示例有自定义编译参数

部分示例的 README 会说明特殊编译参数（如额外的 `-D` 选项或不同的 BOARD），优先使用 README 中说明的编译方法。

### 需要外部硬件连接的示例

如果 README 的「硬件连接」章节说明需要外部传感器、显示屏等外设：
- 在编译前提醒用户确认硬件已连接
- 预期输出可能依赖于外部硬件状态

### 烧录后无串口输出

1. 建议用户按开发板的 Reset 按键
2. 检查串口波特率是否正确
3. 尝试重新烧录
4. 检查 `prj.conf` 中的 `CONFIG_UART_CONSOLE` 等配置

### 多次编译失败

如果自动修复 3 次仍然失败：
1. 整理所有错误信息
2. 列出已尝试的修复方案
3. 给出可能的根因分析
4. 交由用户决策

### picocom 连接问题

如果 picocom 无法连接：
- 检查是否安装：`which picocom`，如未安装提示 `sudo apt install picocom`
- 检查串口权限：`sudo usermod -aG dialout $USER`（需要重新登录生效）
- 使用 pyserial 替代方案进行监控

## 注意事项

1. **串口独占**：烧录和串口监控不能同时使用同一个串口设备，烧录完成后再打开串口
2. **编译目录**：注意 `build.sh` 的工作目录，路径问题是最常见的编译失败原因
3. **固件路径**：烧录时的固件路径必须准确，通常在 `build/` 目录下寻找 `.bin` 文件
4. **超时控制**：串口监控设置合理的超时时间，避免无限等待
5. **不要自动修改用户代码的业务逻辑**：只修复编译错误（如语法错误、缺少头文件等），不要改变示例的功能意图
6. **安全优先**：不要执行 `rm -rf` 或其他危险操作来"修复"问题
7. **设备号不要硬编码**：每次操作前动态扫描，USB 设备号可能随时变化
8. **异常先确认再处理**：所有异常现象必须重复验证，确认非偶发后再进行修复
