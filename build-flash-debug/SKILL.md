---
name: build-flash-debug
description: 全自动编译、烧录、串口调试 ARCS SDK 示例程序，支持自动修复编译错误并验证板上运行结果
---

# ARCS SDK 全自动编译烧录调试器

在 Linux 环境下对 ARCS SDK 示例程序执行完整的 编译 → 烧录 → 串口验证 工作流。自动识别硬件连接、阅读示例文档、编译固件、烧录到板子、通过串口监控运行结果并判断是否正常工作。

## 快速使用

```
编译烧录 samples/drivers/devices/lisa_wdt/basic
编译运行 lisa_gpio output_basic
帮我把 helloworld 烧到板子上看看
调试 lisa_uart send_async_dma
```

## 默认配置

以下为默认值，用户可在触发时覆盖：

| 参数 | 默认值 | 说明 |
|------|--------|------|
| BOARD | `arcs_evb` | 目标开发板 |
| 串口设备 | `/dev/ttyACM0` | USB 串口路径 |
| 烧录波特率 | `3000000` | cskburn 波特率 |
| 串口波特率 | `921600` | picocom 监听波特率 |
| 烧录起始地址 | `0x0` | Flash 烧录偏移 |

## 执行步骤

### 第一阶段：环境检查

#### 1. 确认仓库路径

- 确认当前工作目录位于 `arcs-sdk` 仓库根目录
- 验证 `build.sh`、`tools/burn/cskburn` 等关键文件存在
- 如果不在仓库根目录，尝试通过 `git rev-parse --show-toplevel` 定位

#### 2. 检查硬件连接

- 检查串口设备是否存在：`ls -la /dev/ttyACM0`
- 如果设备不存在：
  - 运行 `ls /dev/ttyACM*` 和 `ls /dev/ttyUSB*` 查找其他可能的设备
  - 运行 `lsusb` 查看 USB 设备列表
  - **告知用户硬件未连接，请求确认后继续**
- 如果设备存在，确认设备权限（用户是否在 `dialout` 组中）
- 检查是否有其他进程占用串口：`fuser /dev/ttyACM0 2>/dev/null`，如有占用提示用户

#### 3. 检查工具链

- 验证 `listenai-dev-tools/` 目录存在（cmake、ninja、toolchain）
- 如果缺失，提示用户运行 `bash prepare_listenai_tools.sh`

### 第二阶段：理解示例

#### 4. 定位示例目录

- 根据用户输入定位示例路径，例如：
  - `lisa_wdt basic` → `samples/drivers/devices/lisa_wdt/basic/`
  - `helloworld` → `samples/helloworld/`
  - 完整路径直接使用
- 如果找不到，在 `samples/` 下搜索匹配的目录名

#### 5. 阅读示例文档

- **必须阅读** 示例目录下的 `README.md` 或 `README.rst`
- 从文档中提取关键信息：
  - **功能说明**：理解这个示例要做什么
  - **硬件连接**：是否需要外部接线（如需要，提醒用户确认）
  - **预期输出**：作为后续验证的参考标准
  - **编译方法**：检查是否使用标准编译流程还是有特殊参数
  - **注意事项**：可能影响运行结果的特殊注意点

#### 6. 阅读源代码

- 阅读示例的 `src/main.c`（或其他源文件）和 `CMakeLists.txt`
- 理解代码逻辑，用于后续判断串口输出是否正确
- 注意代码中的 `printk`/`printf` 输出内容，作为串口验证依据
- 检查 `prj.conf` 和 `Kconfig` 了解配置项

### 第三阶段：编译

#### 7. 执行编译

在仓库根目录下进入示例目录执行编译：

```bash
cd <示例目录>
bash ./build.sh -C -DBOARD=arcs_evb && bash ./build.sh -r -w -DBOARD=arcs_evb
```

**注意：**
- `build.sh` 路径需要根据示例目录的相对位置调整，通常示例的 `build.sh` 是一个软链接或直接使用仓库根目录的 `build.sh`
- 如果示例目录下有自己的 `build.sh`，优先使用它
- 如果没有，回到仓库根目录使用 `-S <示例路径>` 参数编译：
  ```bash
  bash ./build.sh -C -S <示例相对路径> -DBOARD=arcs_evb && bash ./build.sh -r -w -S <示例相对路径> -DBOARD=arcs_evb
  ```
- `-C` 表示先清理构建目录
- `-r` 表示 Release 模式
- `-w` 表示 warnings as errors

#### 8. 处理编译错误

如果编译失败：

1. **仔细阅读错误输出**，提取错误信息
2. **分类处理**：
   - **头文件找不到**：检查 `CMakeLists.txt` 的 include 路径、`prj.conf` 配置
   - **未定义符号**：在仓库中搜索相关符号定义，检查是否缺少依赖
   - **类型错误**：阅读相关 API 头文件，修正代码
   - **链接错误**：检查 `CMakeLists.txt` 依赖、`Kconfig` 配置
   - **配置错误**：检查 `prj.conf` 和 `Kconfig`
3. **在仓库中搜索**相关代码、头文件、配置来定位问题：
   - 使用 Grep 搜索错误涉及的函数/类型/宏定义
   - 查看 `drivers/`、`components/`、`modules/` 下的相关实现
4. **修复后重新编译**
5. **最多尝试 3 轮自动修复**，如果仍然失败，向用户报告问题并请求协助

#### 9. 确认编译产物

- 编译成功后，定位固件文件
- 通常在示例目录的 `build/` 子目录下
- 常见固件文件名模式：`*.bin`、`*.hex`、`*firmware*`
- 检查 `build/` 下查找烧录用的二进制文件（通常是 `.bin` 文件）
- 如果找不到，检查编译输出日志中提到的输出路径

### 第四阶段：烧录

#### 10. 执行烧录

使用 cskburn 烧录固件：

```bash
./tools/burn/cskburn -C arcs -s /dev/ttyACM0 -b 3000000 0x0 <固件文件路径>
```

**参数说明**：
- `-C arcs`：芯片类型
- `-s /dev/ttyACM0`：串口设备
- `-b 3000000`：烧录波特率
- `0x0`：Flash 起始地址
- 最后一个参数是固件 `.bin` 文件路径

**烧录前注意**：
- 确保没有其他程序占用串口（如已打开的 picocom）
- 如果烧录失败，尝试：
  1. 检查串口权限
  2. 确认设备仍然连接（`ls /dev/ttyACM0`）
  3. 重试一次

### 第五阶段：串口验证

#### 11. 打开串口监控

烧录成功后，使用 picocom 监控串口输出：

```bash
picocom -b 921600 /dev/ttyACM0 --lower-dtr --lower-rts --imap=lfcrlf
```

**重要事项**：
- picocom 是交互式程序，使用 Bash 工具运行时设置合理的超时（如 15-30 秒）
- 如果 picocom 无法使用，可以用替代方案：
  ```bash
  stty -F /dev/ttyACM0 921600 raw -echo
  timeout 15 cat /dev/ttyACM0
  ```
- 如果板子需要复位才能看到启动日志，提醒用户按复位键

#### 12. 分析串口输出

将串口输出与第 5、6 步获取的信息对比：

1. **对照预期输出**：与 README 中的「预期输出」章节对比
2. **对照代码逻辑**：检查 `printk`/`printf` 的输出是否按预期顺序和内容出现
3. **检查异常**：
   - 是否有 `ASSERT`、`FATAL`、`panic`、`fault` 等错误信息
   - 是否有 HardFault 或其他异常堆栈
   - 是否有无限重启循环（反复出现启动日志）

#### 13. 输出验证报告

向用户报告验证结果：

```
## 运行验证报告

**示例**: <示例名称>
**目标板**: <BOARD>
**状态**: 正常运行 / 存在异常

### 预期行为
<基于 README 和代码的预期行为描述>

### 实际输出
<关键串口输出内容>

### 判定结果
<对比分析结论>

### 备注
<如有异常的进一步分析或建议>
```

## 特殊情况处理

### 示例有自定义编译参数

部分示例的 README 会说明特殊编译参数（如额外的 `-D` 选项或不同的 BOARD），优先使用 README 中说明的编译方法。

### 需要外部硬件连接的示例

如果 README 的「硬件连接」章节说明需要外部传感器、显示屏等外设：
- 在编译前提醒用户确认硬件已连接
- 预期输出可能依赖于外部硬件状态

### 烧录后无串口输出

1. 建议用户按开发板的 Reset 按键
2. 检查串口波特率是否正确
3. 尝试重新烧录
4. 检查 `prj.conf` 中的 `CONFIG_UART_CONSOLE` 等配置

### 多次编译失败

如果自动修复 3 次仍然失败：
1. 整理所有错误信息
2. 列出已尝试的修复方案
3. 给出可能的根因分析
4. 交由用户决策

### picocom 连接问题

如果 picocom 无法连接：
- 检查是否安装：`which picocom`，如未安装提示 `sudo apt install picocom`
- 检查串口权限：`sudo usermod -aG dialout $USER`（需要重新登录生效）
- 使用替代方案 `cat /dev/ttyACM0` 进行基础监控

## 注意事项

1. **串口独占**：烧录和串口监控不能同时使用同一个串口设备，烧录完成后再打开 picocom
2. **编译目录**：注意 `build.sh` 的工作目录，路径问题是最常见的编译失败原因
3. **固件路径**：烧录时的固件路径必须准确，通常在 `build/` 目录下寻找 `.bin` 文件
4. **超时控制**：串口监控设置合理的超时时间，避免无限等待
5. **不要自动修改用户代码的业务逻辑**：只修复编译错误（如语法错误、缺少头文件等），不要改变示例的功能意图
6. **安全优先**：不要执行 `rm -rf` 或其他危险操作来"修复"问题
